# --- Dev image: hot-reload TypeScript avec tsx ---
FROM node:22-alpine

WORKDIR /usr/src/app

#pour prisma
RUN apk add --no-cache openssl

# 1) Installer d√©pendances
COPY package*.json ./
RUN npm ci

# 2) (Optionnel) Pr√©-g√©n√©rer Prisma si tu souhaites avoir l'auto-compl√©tion dans le conteneur
COPY prisma ./prisma
RUN npx prisma generate

# 3) On ne copie pas le code: il sera mont√© en volume (compose)
# 4) Dossier uploads pour √©viter les erreurs si UPLOAD_DIR pointe ici
RUN mkdir -p /usr/src/app/uploads

EXPOSE 8080
# La commande r√©elle est fournie par docker-compose (npm run dev)


# ============================================================================
# üìò R√©sum√© p√©dagogique complet ‚Äî Dockerfile de d√©veloppement (hot-reload + Prisma)
# ----------------------------------------------------------------------------
# üîπ 1. Objectif du fichier
#
# Ce Dockerfile est con√ßu sp√©cifiquement pour **le d√©veloppement local** :
#   ‚û§ Il cr√©e une image Node.js l√©g√®re bas√©e sur Alpine.
#   ‚û§ Il installe les d√©pendances n√©cessaires (Node + Prisma).
#   ‚û§ Il pr√©pare l‚Äôenvironnement de travail (uploads, client Prisma).
#   ‚û§ Et surtout : il laisse le code source √™tre mont√© dynamiquement depuis l‚Äôh√¥te
#     pour permettre le **hot-reload** automatique.
#
# üí° En clair : ce conteneur n‚Äôest pas destin√© √† la production, mais au **dev rapide**.
#
# ----------------------------------------------------------------------------
# üîπ 2. Ligne par ligne
#
# --------------------------------------------------------------------------
# FROM node:22-alpine
# --------------------------------------------------------------------------
# ‚ûú Base de l‚Äôimage : Node.js v22 sur Alpine Linux.
#   - Alpine est tr√®s l√©g√®re (~5 Mo) ‚Üí builds rapides.
#   - Parfaite pour le d√©veloppement Dockeris√©.
#   - Node 22 = version LTS moderne compatible avec tsx / Prisma.
#
# --------------------------------------------------------------------------
# WORKDIR /usr/src/app
# --------------------------------------------------------------------------
# ‚ûú D√©finit le dossier de travail dans le conteneur.
#   Toutes les commandes suivantes (COPY, RUN, CMD...) se feront depuis ce r√©pertoire.
#
# Exemple : le code sera accessible ici : `/usr/src/app`.
#
# --------------------------------------------------------------------------
# RUN apk add --no-cache openssl
# --------------------------------------------------------------------------
# ‚ûú Installe la librairie OpenSSL (n√©cessaire √† Prisma pour fonctionner correctement).
#   Sans cela, Prisma renverrait une erreur du type :
#     "Prisma failed to detect libssl version".
#
# `--no-cache` permet d‚Äô√©viter de stocker les fichiers d‚Äôinstallation (gain de taille).
#
# --------------------------------------------------------------------------
# COPY package*.json ./
# RUN npm ci
# --------------------------------------------------------------------------
# ‚ûú √âtape d‚Äôinstallation des d√©pendances :
#   - `COPY package*.json ./` : copie uniquement les fichiers de d√©pendances.
#   - `npm ci` : installe les d√©pendances exactes du lockfile (`package-lock.json`).
#
# Avantage :
#   - C‚Äôest plus rapide et reproductible que `npm install`.
#   - Permet √† Docker de **mettre en cache** cette √©tape tant que `package*.json` ne change pas.
#
# --------------------------------------------------------------------------
# COPY prisma ./prisma
# RUN npx prisma generate
# --------------------------------------------------------------------------
# ‚ûú Copie le dossier `prisma/` (o√π se trouve ton `schema.prisma`).
# ‚ûú G√©n√®re le **client Prisma** √† l‚Äôint√©rieur du conteneur.
#
# Cela permet :
#   - d‚Äôutiliser Prisma directement dans le code TypeScript.
#   - d‚Äôavoir l‚Äôauto-compl√©tion dans les IDE connect√©s au conteneur.
#
# --------------------------------------------------------------------------
# # 3) On ne copie pas le code: il sera mont√© en volume (compose)
# --------------------------------------------------------------------------
# ‚ûú Dans un environnement de dev, le code source n‚Äôest **pas copi√©** dans l‚Äôimage.
#   √Ä la place :
#   - Docker Compose montera le dossier local (`./server`) dans le conteneur.
#   - Toute modification locale sera imm√©diatement visible dans le conteneur.
#
# ‚ûú Cela permet le **hot-reload** gr√¢ce √† `tsx --watch` ou `nodemon`.
#
# --------------------------------------------------------------------------
# RUN mkdir -p /usr/src/app/uploads
# --------------------------------------------------------------------------
# ‚ûú Cr√©e un dossier `uploads` pour √©viter les erreurs d‚Äôacc√®s disque.
#   Cela correspond au chemin utilis√© par la variable `UPLOAD_DIR`.
#
# Ce r√©pertoire est souvent mont√© comme un volume dans `docker-compose.yml`
# pour persister les fichiers envoy√©s par les utilisateurs.
#
# --------------------------------------------------------------------------
# EXPOSE 8080
# --------------------------------------------------------------------------
# ‚ûú Documente le port d‚Äô√©coute principal de ton application Express.
#   - Port 8080 ‚Üí serveur HTTP principal.
#
# ‚ö†Ô∏è Cette instruction **n‚Äôouvre pas r√©ellement le port** :
#   la publication se fait dans `docker-compose.yml` via :
#     ports:
#       - "8080:8080"
#
# --------------------------------------------------------------------------
# # La commande r√©elle est fournie par docker-compose (npm run dev)
# --------------------------------------------------------------------------
# ‚ûú Ce Dockerfile ne d√©finit pas de `CMD` (commande par d√©faut),
#   car c‚Äôest `docker-compose.yml` qui pr√©cise :
#     command: ["npm", "run", "dev"]
#
#   Cela laisse la flexibilit√© de changer la commande sans rebuild de l‚Äôimage.
#
# ----------------------------------------------------------------------------
# üîπ 3. Cycle d‚Äôutilisation (dans Docker Compose)
#
# 1Ô∏è‚É£ Docker construit cette image une seule fois.
# 2Ô∏è‚É£ Le conteneur d√©marre avec `npm run dev` (donc `tsx watch src/index.ts`).
# 3Ô∏è‚É£ Ton code source est mont√© en volume ‚Üí tout changement red√©marre automatiquement.
# 4Ô∏è‚É£ Prisma, Express, etc. tournent comme s‚Äôils √©taient install√©s localement.
#
# ----------------------------------------------------------------------------
# üîπ 4. Bonnes pratiques p√©dagogiques
#
# ‚úÖ Toujours isoler l‚Äôenvironnement de dev (Dockerfile.dev s√©par√© du Dockerfile prod).
# ‚úÖ Monter le code via volume pour profiter du hot-reload.
# ‚úÖ Installer uniquement les d√©pendances (pas le code source) dans l‚Äôimage.
# ‚úÖ Documenter les ports expos√©s pour la clart√©.
# ‚úÖ Utiliser `npm ci` pour des builds reproductibles.
# ‚úÖ Pr√©parer Prisma dans le conteneur pour √©viter les erreurs de runtime.
#
# ----------------------------------------------------------------------------
# üí° En r√©sum√© :
#
# Ce Dockerfile de d√©veloppement cr√©e un environnement complet et isol√©
# pour coder avec Express + TypeScript + Prisma :
#   - hot-reload actif gr√¢ce √† `tsx watch`,
#   - Prisma client g√©n√©r√© √† l‚Äôavance,
#   - code mont√© depuis l‚Äôh√¥te,
#   - d√©pendances install√©es proprement.
#
# ‚û§ P√©dagogiquement :
#   - Il montre la diff√©rence entre image de dev et image de prod.
#   - Il illustre la notion de **volumes** et de **couches Docker**.
#   - Il initie √† l‚Äôusage de Prisma dans un environnement conteneuris√©.
#   - Il sensibilise √† la reproductibilit√© et la modularit√© des environnements Node.js.
# ============================================================================