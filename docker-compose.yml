networks:
  app-net:
    driver: bridge

volumes:
  pg_data:
  mongo_data:
  upload_data:

services:
  client:
    build: ./client
    container_name: fs_client
    working_dir: /app
    environment:
      - VITE_API_URL=http://localhost:8080   # le navigateur contacte l'API via l'h√¥te
      - CHOKIDAR_USEPOLLING=true
      - WATCHPACK_POLLING=true
      - BROWSER=none
    ports:
      - "5173:5173"
    volumes:
      - ./client:/app
      - /app/node_modules
    depends_on:
      - api
    command: ["npm","run","dev","--","--host"]
    networks: [app-net]

  api:
    build: 
      context: ./server
      dockerfile: Dockerfile.dev
      # prod-> dockerfile: Dockerfile
    container_name: fs_api
    working_dir: /usr/src/app
    # Charge d'abord .env (base), puis .env.docker (override des valeurs Docker)
    env_file:
      - ./.env
      - ./.env.docker
    ports:
      - "8080:8080"
      - "5555:5555"   # Prisma Studio (optionnel)
    volumes:
      - ./server:/usr/src/app
      - /usr/src/app/node_modules
      - upload_data:/usr/src/app/uploads
    depends_on:
      postgres:
        condition: service_healthy
      mongo:
        condition: service_started
    command: ["npm","run","dev"] 
    # command: ["npm","run", "dev:wait"]  # Utiliser cette ligne si vous avez un script pour attendre la DB
    networks: [app-net]

  postgres:
    image: postgres:16-alpine
    container_name: fs_postgres
    environment:
      POSTGRES_DB: appdb
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d appdb"]
      interval: 5s
      timeout: 3s
      retries: 20
    ports:
      - "5432:5432"
    volumes:
      - pg_data:/var/lib/postgresql/data
    networks: [app-net]

  mongo:
    image: mongo:7
    container_name: fs_mongo
    ports:
      - "27017:27017"
    volumes:
      - mongo_data:/data/db
    networks: [app-net]


# =============================================================================
# üìò R√©sum√© p√©dagogique complet ‚Äî Lecture de ce docker-compose.yml
# -----------------------------------------------------------------------------
# üéØ Objectif du fichier
# Ce compose d√©crit une stack de dev compl√®te :
#   ‚Ä¢ client (Vite/React)  ‚Ä¢ api (Express/TS/Prisma)  ‚Ä¢ postgres  ‚Ä¢ mongo
# Il orchestre les conteneurs, leur r√©seau, leurs volumes persistants et
# l‚Äôinjection de variables d‚Äôenvironnement (.env + .env.docker).
#
# -----------------------------------------------------------------------------
# üîó R√©seaux
# networks.app-net (bridge) :
#   ‚Ä¢ Chaque service rejoint un r√©seau priv√© Docker.
#   ‚Ä¢ Le NOM du service = hostname DNS interne (ex: "postgres", "mongo").
#   ‚Ä¢ C‚Äôest pourquoi DATABASE_URL/MONGO_URL pointent vers postgres/mongo
#     au lieu de localhost dans .env.docker.
#
# -----------------------------------------------------------------------------
# üíæ Volumes persistants
# volumes:
#   ‚Ä¢ pg_data       ‚Üí conserve les donn√©es PostgreSQL
#   ‚Ä¢ mongo_data    ‚Üí conserve les donn√©es MongoDB
#   ‚Ä¢ upload_data   ‚Üí conserve les fichiers upload√©s
# B√©n√©fice : vos donn√©es survivent aux `down` / `rebuild` des conteneurs.
#
# -----------------------------------------------------------------------------
# üß© Service client (Vite)
# - Monte ./client dans /app ‚Üí hot-reload instantan√©.
# - VITE_API_URL=http://localhost:8080 : le navigateur (hors conteneur) contacte
#   l‚ÄôAPI via la machine h√¥te.
# - --host : Vite √©coute en 0.0.0.0 dans le conteneur.
# - CHOKIDAR_USEPOLLING/WATCHPACK_POLLING : fiabilise les watchers sous Docker/WSL2.
#
# -----------------------------------------------------------------------------
# ‚öôÔ∏è Service api (Express/TypeScript/Prisma)
# - build ‚Üí Dockerfile.dev (dev). En prod, utiliser un Dockerfile multi-stage.
# - env_file: [.env, .env.docker]
#     ‚Ä¢ .env = base commune (JWT, TTL, CORS, etc.)
#     ‚Ä¢ .env.docker = overrides r√©seau/chemins (hosts postgres/mongo, UPLOAD_DIR)
#   ‚Üí Workflow pro : m√™me code, configs selon environnement, pas de duplication.
# - volumes:
#     ‚Ä¢ ./server:/usr/src/app        ‚Üí hot-reload TS via tsx/nodemon
#     ‚Ä¢ /usr/src/app/node_modules    ‚Üí volume anonyme pour conserver l‚Äôinstall conteneur
#     ‚Ä¢ upload_data:/usr/src/app/uploads ‚Üí persistance des fichiers
# - depends_on:
#     ‚Ä¢ postgres: service_healthy (attend que PG r√©ponde √† pg_isready)
#     ‚Ä¢ mongo: service_started (d√©marr√©, sans healthcheck)
# - command: ["npm","run","dev"] (ou "dev:wait" si vous utilisez wait-on tcp:postgres:5432)
#
# -----------------------------------------------------------------------------
# üêò Service postgres
# - Image postgres:16-alpine, variables d‚Äôinit (DB/USER/PASSWORD).
# - Healthcheck pg_isready ‚Üí permet √† l‚ÄôAPI d‚Äôattendre une DB pr√™te.
# - Port 5432 expos√© pour outils locaux (psql, IDE).
#
# -----------------------------------------------------------------------------
# üçÉ Service mongo
# - Image mongo:7, port 27017 expos√© pour Compass/mongosh.
# - Volume mongo_data pour la persistance.
#
# -----------------------------------------------------------------------------
# üí° Pourquoi ce workflow .env + .env.docker ?
# - .env contient la configuration commune (s√©curit√©, CORS, TTL, etc.).
# - .env.docker remplace uniquement ce qui change en conteneur :
#     ‚Ä¢ hosts DB (postgres/mongo) au lieu de localhost
#     ‚Ä¢ chemins absolus (UPLOAD_DIR) coh√©rents avec WORKDIR
# Avantages :
#   ‚úÖ Une seule source de v√©rit√© pour les nouvelles variables (.env)
#   ‚úÖ Override minimal et explicite c√¥t√© Docker
#   ‚úÖ Z√©ro modification du code entre local et conteneur
#
# -----------------------------------------------------------------------------
# üèéÔ∏è Hot-reload & productivit√©
# - Front : Vite + volumes ‚Üí rechargement instantan√©.
# - API  : tsx watch + volumes ‚Üí relance √† chaque modification TS.
# - Prisma Studio (5555) accessible depuis l‚Äôh√¥te pour explorer la DB.
#
# -----------------------------------------------------------------------------
# ‚úÖ Bonnes pratiques
# - S√©parer Dockerfile.dev (dev) et Dockerfile (prod multi-stage).
# - Ajouter des healthchecks aux services critiques (d√©j√† pour Postgres).
# - Versionner `.env.example`, ignorer `.env*` sensibles.
# - Centraliser l‚Äôacc√®s aux variables via un `env.ts` (validation + typage).
#
# -----------------------------------------------------------------------------
# üß≠ En r√©sum√©
# Ce compose met en place un environnement de dev pro :
#   ‚Ä¢ R√©seau priv√© avec DNS par nom de service
#   ‚Ä¢ Donn√©es persistantes (DB & uploads)
#   ‚Ä¢ Hot-reload front/back
#   ‚Ä¢ Configs propres via .env + .env.docker
#   ‚Ä¢ D√©marrage ordonn√© gr√¢ce aux conditions depends_on/healthcheck
# C‚Äôest un socle reproductible, lisible et pr√™t pour √©voluer vers une
# image de production (multi-stage) et un compose d√©di√© au d√©ploiement.
# =============================================================================